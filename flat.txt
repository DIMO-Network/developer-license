// SPDX-License-Identifier: MIT
pragma solidity =0.8.22 ^0.8.13 ^0.8.20;

// lib/openzeppelin-contracts/contracts/access/IAccessControl.sol

// OpenZeppelin Contracts (last updated v5.0.0) (access/IAccessControl.sol)

/**
 * @dev External interface of AccessControl declared to support ERC165 detection.
 */
interface IAccessControl {
    /**
     * @dev The `account` is missing a role.
     */
    error AccessControlUnauthorizedAccount(address account, bytes32 neededRole);

    /**
     * @dev The caller of a function is not the expected one.
     *
     * NOTE: Don't confuse with {AccessControlUnauthorizedAccount}.
     */
    error AccessControlBadConfirmation();

    /**
     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`
     *
     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite
     * {RoleAdminChanged} not being emitted signaling this.
     */
    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);

    /**
     * @dev Emitted when `account` is granted `role`.
     *
     * `sender` is the account that originated the contract call, an admin role
     * bearer except when using {AccessControl-_setupRole}.
     */
    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Emitted when `account` is revoked `role`.
     *
     * `sender` is the account that originated the contract call:
     *   - if using `revokeRole`, it is the admin role bearer
     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)
     */
    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) external view returns (bool);

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {AccessControl-_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) external view returns (bytes32);

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function grantRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     */
    function revokeRole(bytes32 role, address account) external;

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been granted `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `callerConfirmation`.
     */
    function renounceRole(bytes32 role, address callerConfirmation) external;
}

// lib/openzeppelin-contracts/contracts/utils/Base64.sol

// OpenZeppelin Contracts (last updated v5.0.0) (utils/Base64.sol)

/**
 * @dev Provides a set of functions to operate with Base64 strings.
 */
library Base64 {
    /**
     * @dev Base64 Encoding/Decoding Table
     */
    string internal constant _TABLE = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

    /**
     * @dev Converts a `bytes` to its Bytes64 `string` representation.
     */
    function encode(bytes memory data) internal pure returns (string memory) {
        /**
         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence
         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol
         */
        if (data.length == 0) return "";

        // Loads the table into memory
        string memory table = _TABLE;

        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter
        // and split into 4 numbers of 6 bits.
        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up
        // - `data.length + 2`  -> Round up
        // - `/ 3`              -> Number of 3-bytes chunks
        // - `4 *`              -> 4 characters for each chunk
        string memory result = new string(4 * ((data.length + 2) / 3));

        /// @solidity memory-safe-assembly
        assembly {
            // Prepare the lookup table (skip the first "length" byte)
            let tablePtr := add(table, 1)

            // Prepare result pointer, jump over length
            let resultPtr := add(result, 32)

            // Run over the input, 3 bytes at a time
            for {
                let dataPtr := data
                let endPtr := add(data, mload(data))
            } lt(dataPtr, endPtr) {

            } {
                // Advance 3 bytes
                dataPtr := add(dataPtr, 3)
                let input := mload(dataPtr)

                // To write each character, shift the 3 bytes (18 bits) chunk
                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)
                // and apply logical AND with 0x3F which is the number of
                // the previous character in the ASCII table prior to the Base64 Table
                // The result is then added to the table to get the character to write,
                // and finally write it in the result pointer but with a left shift
                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits

                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))
                resultPtr := add(resultPtr, 1) // Advance

                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))
                resultPtr := add(resultPtr, 1) // Advance

                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))
                resultPtr := add(resultPtr, 1) // Advance

                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))
                resultPtr := add(resultPtr, 1) // Advance
            }

            // When data `bytes` is not exactly 3 bytes long
            // it is padded with `=` characters at the end
            switch mod(mload(data), 3)
            case 1 {
                mstore8(sub(resultPtr, 1), 0x3d)
                mstore8(sub(resultPtr, 2), 0x3d)
            }
            case 2 {
                mstore8(sub(resultPtr, 1), 0x3d)
            }
        }

        return result;
    }
}

// lib/openzeppelin-contracts/contracts/utils/Context.sol

// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)

/**
 * @dev Provides information about the current execution context, including the
 * sender of the transaction and its data. While these are generally available
 * via msg.sender and msg.data, they should not be accessed in such a direct
 * manner, since when dealing with meta-transactions the account sending and
 * paying for execution may not be the actual sender (as far as an application
 * is concerned).
 *
 * This contract is only required for intermediate, library-like contracts.
 */
abstract contract Context {
    function _msgSender() internal view virtual returns (address) {
        return msg.sender;
    }

    function _msgData() internal view virtual returns (bytes calldata) {
        return msg.data;
    }

    function _contextSuffixLength() internal view virtual returns (uint256) {
        return 0;
    }
}

// lib/openzeppelin-contracts/contracts/utils/ReentrancyGuard.sol

// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)

/**
 * @dev Contract module that helps prevent reentrant calls to a function.
 *
 * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier
 * available, which can be applied to functions to make sure there are no nested
 * (reentrant) calls to them.
 *
 * Note that because there is a single `nonReentrant` guard, functions marked as
 * `nonReentrant` may not call one another. This can be worked around by making
 * those functions `private`, and then adding `external` `nonReentrant` entry
 * points to them.
 *
 * TIP: If you would like to learn more about reentrancy and alternative ways
 * to protect against it, check out our blog post
 * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].
 */
abstract contract ReentrancyGuard {
    // Booleans are more expensive than uint256 or any type that takes up a full
    // word because each write operation emits an extra SLOAD to first read the
    // slot's contents, replace the bits taken up by the boolean, and then write
    // back. This is the compiler's defense against contract upgrades and
    // pointer aliasing, and it cannot be disabled.

    // The values being non-zero value makes deployment a bit more expensive,
    // but in exchange the refund on every call to nonReentrant will be lower in
    // amount. Since refunds are capped to a percentage of the total
    // transaction's gas, it is best to keep them low in cases like this one, to
    // increase the likelihood of the full refund coming into effect.
    uint256 private constant NOT_ENTERED = 1;
    uint256 private constant ENTERED = 2;

    uint256 private _status;

    /**
     * @dev Unauthorized reentrant call.
     */
    error ReentrancyGuardReentrantCall();

    constructor() {
        _status = NOT_ENTERED;
    }

    /**
     * @dev Prevents a contract from calling itself, directly or indirectly.
     * Calling a `nonReentrant` function from another `nonReentrant`
     * function is not supported. It is possible to prevent this from happening
     * by making the `nonReentrant` function external, and making it call a
     * `private` function that does the actual work.
     */
    modifier nonReentrant() {
        _nonReentrantBefore();
        _;
        _nonReentrantAfter();
    }

    function _nonReentrantBefore() private {
        // On the first call to nonReentrant, _status will be NOT_ENTERED
        if (_status == ENTERED) {
            revert ReentrancyGuardReentrantCall();
        }

        // Any calls to nonReentrant after this point will fail
        _status = ENTERED;
    }

    function _nonReentrantAfter() private {
        // By storing the original value once again, a refund is triggered (see
        // https://eips.ethereum.org/EIPS/eip-2200)
        _status = NOT_ENTERED;
    }

    /**
     * @dev Returns true if the reentrancy guard is currently set to "entered", which indicates there is a
     * `nonReentrant` function in the call stack.
     */
    function _reentrancyGuardEntered() internal view returns (bool) {
        return _status == ENTERED;
    }
}

// lib/openzeppelin-contracts/contracts/utils/introspection/IERC165.sol

// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)

/**
 * @dev Interface of the ERC165 standard, as defined in the
 * https://eips.ethereum.org/EIPS/eip-165[EIP].
 *
 * Implementers can declare support of contract interfaces, which can then be
 * queried by others ({ERC165Checker}).
 *
 * For an implementation, see {ERC165}.
 */
interface IERC165 {
    /**
     * @dev Returns true if this contract implements the interface defined by
     * `interfaceId`. See the corresponding
     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]
     * to learn more about how these ids are created.
     *
     * This function call must use less than 30 000 gas.
     */
    function supportsInterface(bytes4 interfaceId) external view returns (bool);
}

// lib/openzeppelin-contracts/contracts/utils/math/Math.sol

// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)

/**
 * @dev Standard math utilities missing in the Solidity language.
 */
library Math {
    /**
     * @dev Muldiv operation overflow.
     */
    error MathOverflowedMulDiv();

    enum Rounding {
        Floor, // Toward negative infinity
        Ceil, // Toward positive infinity
        Trunc, // Toward zero
        Expand // Away from zero
    }

    /**
     * @dev Returns the addition of two unsigned integers, with an overflow flag.
     */
    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            uint256 c = a + b;
            if (c < a) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.
     */
    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b > a) return (false, 0);
            return (true, a - b);
        }
    }

    /**
     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.
     */
    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the
            // benefit is lost if 'b' is also tested.
            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522
            if (a == 0) return (true, 0);
            uint256 c = a * b;
            if (c / a != b) return (false, 0);
            return (true, c);
        }
    }

    /**
     * @dev Returns the division of two unsigned integers, with a division by zero flag.
     */
    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a / b);
        }
    }

    /**
     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.
     */
    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {
        unchecked {
            if (b == 0) return (false, 0);
            return (true, a % b);
        }
    }

    /**
     * @dev Returns the largest of two numbers.
     */
    function max(uint256 a, uint256 b) internal pure returns (uint256) {
        return a > b ? a : b;
    }

    /**
     * @dev Returns the smallest of two numbers.
     */
    function min(uint256 a, uint256 b) internal pure returns (uint256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two numbers. The result is rounded towards
     * zero.
     */
    function average(uint256 a, uint256 b) internal pure returns (uint256) {
        // (a + b) / 2 can overflow.
        return (a & b) + (a ^ b) / 2;
    }

    /**
     * @dev Returns the ceiling of the division of two numbers.
     *
     * This differs from standard division with `/` in that it rounds towards infinity instead
     * of rounding towards zero.
     */
    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {
        if (b == 0) {
            // Guarantee the same behavior as in a regular Solidity division.
            return a / b;
        }

        // (a + b - 1) / b can overflow on addition, so we distribute.
        return a == 0 ? 0 : (a - 1) / b + 1;
    }

    /**
     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or
     * denominator == 0.
     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by
     * Uniswap Labs also under MIT license.
     */
    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {
        unchecked {
            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use
            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256
            // variables such that product = prod1 * 2^256 + prod0.
            uint256 prod0 = x * y; // Least significant 256 bits of the product
            uint256 prod1; // Most significant 256 bits of the product
            assembly {
                let mm := mulmod(x, y, not(0))
                prod1 := sub(sub(mm, prod0), lt(mm, prod0))
            }

            // Handle non-overflow cases, 256 by 256 division.
            if (prod1 == 0) {
                // Solidity will revert if denominator == 0, unlike the div opcode on its own.
                // The surrounding unchecked block does not change this fact.
                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.
                return prod0 / denominator;
            }

            // Make sure the result is less than 2^256. Also prevents denominator == 0.
            if (denominator <= prod1) {
                revert MathOverflowedMulDiv();
            }

            ///////////////////////////////////////////////
            // 512 by 256 division.
            ///////////////////////////////////////////////

            // Make division exact by subtracting the remainder from [prod1 prod0].
            uint256 remainder;
            assembly {
                // Compute remainder using mulmod.
                remainder := mulmod(x, y, denominator)

                // Subtract 256 bit number from 512 bit number.
                prod1 := sub(prod1, gt(remainder, prod0))
                prod0 := sub(prod0, remainder)
            }

            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.
            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.

            uint256 twos = denominator & (0 - denominator);
            assembly {
                // Divide denominator by twos.
                denominator := div(denominator, twos)

                // Divide [prod1 prod0] by twos.
                prod0 := div(prod0, twos)

                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.
                twos := add(div(sub(0, twos), twos), 1)
            }

            // Shift in bits from prod1 into prod0.
            prod0 |= prod1 * twos;

            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such
            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for
            // four bits. That is, denominator * inv = 1 mod 2^4.
            uint256 inverse = (3 * denominator) ^ 2;

            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also
            // works in modular arithmetic, doubling the correct bits in each step.
            inverse *= 2 - denominator * inverse; // inverse mod 2^8
            inverse *= 2 - denominator * inverse; // inverse mod 2^16
            inverse *= 2 - denominator * inverse; // inverse mod 2^32
            inverse *= 2 - denominator * inverse; // inverse mod 2^64
            inverse *= 2 - denominator * inverse; // inverse mod 2^128
            inverse *= 2 - denominator * inverse; // inverse mod 2^256

            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.
            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is
            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1
            // is no longer required.
            result = prod0 * inverse;
            return result;
        }
    }

    /**
     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.
     */
    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {
        uint256 result = mulDiv(x, y, denominator);
        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {
            result += 1;
        }
        return result;
    }

    /**
     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded
     * towards zero.
     *
     * Inspired by Henry S. Warren, Jr.'s "Hacker's Delight" (Chapter 11).
     */
    function sqrt(uint256 a) internal pure returns (uint256) {
        if (a == 0) {
            return 0;
        }

        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.
        //
        // We know that the "msb" (most significant bit) of our target number `a` is a power of 2 such that we have
        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.
        //
        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`
        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`
        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`
        //
        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.
        uint256 result = 1 << (log2(a) >> 1);

        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,
        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at
        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision
        // into the expected uint128 result.
        unchecked {
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            result = (result + a / result) >> 1;
            return min(result, a / result);
        }
    }

    /**
     * @notice Calculates sqrt(a), following the selected rounding direction.
     */
    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = sqrt(a);
            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 2 of a positive value rounded towards zero.
     * Returns 0 if given 0.
     */
    function log2(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >> 128 > 0) {
                value >>= 128;
                result += 128;
            }
            if (value >> 64 > 0) {
                value >>= 64;
                result += 64;
            }
            if (value >> 32 > 0) {
                value >>= 32;
                result += 32;
            }
            if (value >> 16 > 0) {
                value >>= 16;
                result += 16;
            }
            if (value >> 8 > 0) {
                value >>= 8;
                result += 8;
            }
            if (value >> 4 > 0) {
                value >>= 4;
                result += 4;
            }
            if (value >> 2 > 0) {
                value >>= 2;
                result += 2;
            }
            if (value >> 1 > 0) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log2(value);
            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 10 of a positive value rounded towards zero.
     * Returns 0 if given 0.
     */
    function log10(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >= 10 ** 64) {
                value /= 10 ** 64;
                result += 64;
            }
            if (value >= 10 ** 32) {
                value /= 10 ** 32;
                result += 32;
            }
            if (value >= 10 ** 16) {
                value /= 10 ** 16;
                result += 16;
            }
            if (value >= 10 ** 8) {
                value /= 10 ** 8;
                result += 8;
            }
            if (value >= 10 ** 4) {
                value /= 10 ** 4;
                result += 4;
            }
            if (value >= 10 ** 2) {
                value /= 10 ** 2;
                result += 2;
            }
            if (value >= 10 ** 1) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log10(value);
            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);
        }
    }

    /**
     * @dev Return the log in base 256 of a positive value rounded towards zero.
     * Returns 0 if given 0.
     *
     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.
     */
    function log256(uint256 value) internal pure returns (uint256) {
        uint256 result = 0;
        unchecked {
            if (value >> 128 > 0) {
                value >>= 128;
                result += 16;
            }
            if (value >> 64 > 0) {
                value >>= 64;
                result += 8;
            }
            if (value >> 32 > 0) {
                value >>= 32;
                result += 4;
            }
            if (value >> 16 > 0) {
                value >>= 16;
                result += 2;
            }
            if (value >> 8 > 0) {
                result += 1;
            }
        }
        return result;
    }

    /**
     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.
     * Returns 0 if given 0.
     */
    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {
        unchecked {
            uint256 result = log256(value);
            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);
        }
    }

    /**
     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.
     */
    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {
        return uint8(rounding) % 2 == 1;
    }
}

// lib/openzeppelin-contracts/contracts/utils/math/SignedMath.sol

// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)

/**
 * @dev Standard signed math utilities missing in the Solidity language.
 */
library SignedMath {
    /**
     * @dev Returns the largest of two signed numbers.
     */
    function max(int256 a, int256 b) internal pure returns (int256) {
        return a > b ? a : b;
    }

    /**
     * @dev Returns the smallest of two signed numbers.
     */
    function min(int256 a, int256 b) internal pure returns (int256) {
        return a < b ? a : b;
    }

    /**
     * @dev Returns the average of two signed numbers without overflow.
     * The result is rounded towards zero.
     */
    function average(int256 a, int256 b) internal pure returns (int256) {
        // Formula from the book "Hacker's Delight"
        int256 x = (a & b) + ((a ^ b) >> 1);
        return x + (int256(uint256(x) >> 255) & (a ^ b));
    }

    /**
     * @dev Returns the absolute unsigned value of a signed value.
     */
    function abs(int256 n) internal pure returns (uint256) {
        unchecked {
            // must be unchecked in order to support `n = type(int256).min`
            return uint256(n >= 0 ? n : -n);
        }
    }
}

// src/interface/IDevLicenseDimo.sol

interface IDevLicenseDimo {
    function isSigner(uint256 tokenId, address account) external view returns (bool);
}

// src/interface/IDimoCredit.sol

interface IDimoCredit {
    function receiver() external view returns (address);
    function dimoCreditRate() external view returns (uint256);
    function burn(address from, uint256 amount) external;
    function transferFrom(address from, address to, uint256 value) external returns (bool);
    function mintAmountDc(
        address to, 
        uint256 dimoCredits,
        bytes calldata data) external returns(uint256 amountIn);
    function mint(
            address to, 
            uint256 amountIn,
            bytes calldata data
            ) external returns(uint256 dimoCredits);
    function grantRole(bytes32 role, address account) external;
}

// src/interface/IDimoToken.sol

interface IDimoToken {
    
    function transfer(address to, uint256 amount) external returns (bool);
    function transferFrom(address from, address to, uint256 value) external returns (bool);

    function balanceOf(address _owner) external view returns (uint256 balance);

    function approve(address spender, uint256 value) external returns (bool success);
    function burn(address user, uint256 amount) external;
    function grantRole(bytes32 role, address account) external;
}

// src/interface/ILicenseAccountFactory.sol

interface ILicenseAccountFactory {
    function setLicense(address license) external;
    function create(uint256 tokenId) external returns (address clone);
}

// src/provider/IOracleSource.sol

interface IOracleSource {

    function updatePrice() external;
    function isUpdatable() external view returns (bool updatable);
    
    /** 
     * @return amountUsdPerToken The amount of USD you would get in exchange for 1 $DIMO, with 18 decimal places
     * @return updateTimestamp The timestamp at which the price was last set
     **/
    function getAmountUsdPerToken() external returns (uint256 amountUsdPerToken, uint256 updateTimestamp);
    function getAmountUsdPerToken(bytes calldata data) external returns (uint256 amountUsdPerToken, uint256 updateTimestamp);

    function getAmountNativePerToken() external returns (uint256 amountNativePerToken, uint256 updateTimestamp);
    function getAmountNativePerToken(bytes calldata data) external returns (uint256 amountNativePerToken, uint256 updateTimestamp);
}

// lib/openzeppelin-contracts/contracts/access/Ownable.sol

// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)

/**
 * @dev Contract module which provides a basic access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * The initial owner is set to the address provided by the deployer. This can
 * later be changed with {transferOwnership}.
 *
 * This module is used through inheritance. It will make available the modifier
 * `onlyOwner`, which can be applied to your functions to restrict their use to
 * the owner.
 */
abstract contract Ownable is Context {
    address private _owner;

    /**
     * @dev The caller account is not authorized to perform an operation.
     */
    error OwnableUnauthorizedAccount(address account);

    /**
     * @dev The owner is not a valid owner account. (eg. `address(0)`)
     */
    error OwnableInvalidOwner(address owner);

    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.
     */
    constructor(address initialOwner) {
        if (initialOwner == address(0)) {
            revert OwnableInvalidOwner(address(0));
        }
        _transferOwnership(initialOwner);
    }

    /**
     * @dev Throws if called by any account other than the owner.
     */
    modifier onlyOwner() {
        _checkOwner();
        _;
    }

    /**
     * @dev Returns the address of the current owner.
     */
    function owner() public view virtual returns (address) {
        return _owner;
    }

    /**
     * @dev Throws if the sender is not the owner.
     */
    function _checkOwner() internal view virtual {
        if (owner() != _msgSender()) {
            revert OwnableUnauthorizedAccount(_msgSender());
        }
    }

    /**
     * @dev Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions. Can only be called by the current owner.
     *
     * NOTE: Renouncing ownership will leave the contract without an owner,
     * thereby disabling any functionality that is only available to the owner.
     */
    function renounceOwnership() public virtual onlyOwner {
        _transferOwnership(address(0));
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual onlyOwner {
        if (newOwner == address(0)) {
            revert OwnableInvalidOwner(address(0));
        }
        _transferOwnership(newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`).
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual {
        address oldOwner = _owner;
        _owner = newOwner;
        emit OwnershipTransferred(oldOwner, newOwner);
    }
}

// lib/openzeppelin-contracts/contracts/utils/introspection/ERC165.sol

// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)

/**
 * @dev Implementation of the {IERC165} interface.
 *
 * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check
 * for the additional interface id that will be supported. For example:
 *
 * ```solidity
 * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
 *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);
 * }
 * ```
 */
abstract contract ERC165 is IERC165 {
    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {
        return interfaceId == type(IERC165).interfaceId;
    }
}

// lib/openzeppelin-contracts/contracts/access/Ownable2Step.sol

// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable2Step.sol)

/**
 * @dev Contract module which provides access control mechanism, where
 * there is an account (an owner) that can be granted exclusive access to
 * specific functions.
 *
 * The initial owner is specified at deployment time in the constructor for `Ownable`. This
 * can later be changed with {transferOwnership} and {acceptOwnership}.
 *
 * This module is used through inheritance. It will make available all functions
 * from parent (Ownable).
 */
abstract contract Ownable2Step is Ownable {
    address private _pendingOwner;

    event OwnershipTransferStarted(address indexed previousOwner, address indexed newOwner);

    /**
     * @dev Returns the address of the pending owner.
     */
    function pendingOwner() public view virtual returns (address) {
        return _pendingOwner;
    }

    /**
     * @dev Starts the ownership transfer of the contract to a new account. Replaces the pending transfer if there is one.
     * Can only be called by the current owner.
     */
    function transferOwnership(address newOwner) public virtual override onlyOwner {
        _pendingOwner = newOwner;
        emit OwnershipTransferStarted(owner(), newOwner);
    }

    /**
     * @dev Transfers ownership of the contract to a new account (`newOwner`) and deletes any pending owner.
     * Internal function without access restriction.
     */
    function _transferOwnership(address newOwner) internal virtual override {
        delete _pendingOwner;
        super._transferOwnership(newOwner);
    }

    /**
     * @dev The new owner accepts the ownership transfer.
     */
    function acceptOwnership() public virtual {
        address sender = _msgSender();
        if (pendingOwner() != sender) {
            revert OwnableUnauthorizedAccount(sender);
        }
        _transferOwnership(sender);
    }
}

// lib/openzeppelin-contracts/contracts/utils/Strings.sol

// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)

/**
 * @dev String operations.
 */
library Strings {
    bytes16 private constant HEX_DIGITS = "0123456789abcdef";
    uint8 private constant ADDRESS_LENGTH = 20;

    /**
     * @dev The `value` string doesn't fit in the specified `length`.
     */
    error StringsInsufficientHexLength(uint256 value, uint256 length);

    /**
     * @dev Converts a `uint256` to its ASCII `string` decimal representation.
     */
    function toString(uint256 value) internal pure returns (string memory) {
        unchecked {
            uint256 length = Math.log10(value) + 1;
            string memory buffer = new string(length);
            uint256 ptr;
            /// @solidity memory-safe-assembly
            assembly {
                ptr := add(buffer, add(32, length))
            }
            while (true) {
                ptr--;
                /// @solidity memory-safe-assembly
                assembly {
                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))
                }
                value /= 10;
                if (value == 0) break;
            }
            return buffer;
        }
    }

    /**
     * @dev Converts a `int256` to its ASCII `string` decimal representation.
     */
    function toStringSigned(int256 value) internal pure returns (string memory) {
        return string.concat(value < 0 ? "-" : "", toString(SignedMath.abs(value)));
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.
     */
    function toHexString(uint256 value) internal pure returns (string memory) {
        unchecked {
            return toHexString(value, Math.log256(value) + 1);
        }
    }

    /**
     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.
     */
    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {
        uint256 localValue = value;
        bytes memory buffer = new bytes(2 * length + 2);
        buffer[0] = "0";
        buffer[1] = "x";
        for (uint256 i = 2 * length + 1; i > 1; --i) {
            buffer[i] = HEX_DIGITS[localValue & 0xf];
            localValue >>= 4;
        }
        if (localValue != 0) {
            revert StringsInsufficientHexLength(value, length);
        }
        return string(buffer);
    }

    /**
     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal
     * representation.
     */
    function toHexString(address addr) internal pure returns (string memory) {
        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);
    }

    /**
     * @dev Returns true if the two strings are equal.
     */
    function equal(string memory a, string memory b) internal pure returns (bool) {
        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));
    }
}

// lib/openzeppelin-contracts/contracts/access/AccessControl.sol

// OpenZeppelin Contracts (last updated v5.0.0) (access/AccessControl.sol)

/**
 * @dev Contract module that allows children to implement role-based access
 * control mechanisms. This is a lightweight version that doesn't allow enumerating role
 * members except through off-chain means by accessing the contract event logs. Some
 * applications may benefit from on-chain enumerability, for those cases see
 * {AccessControlEnumerable}.
 *
 * Roles are referred to by their `bytes32` identifier. These should be exposed
 * in the external API and be unique. The best way to achieve this is by
 * using `public constant` hash digests:
 *
 * ```solidity
 * bytes32 public constant MY_ROLE = keccak256("MY_ROLE");
 * ```
 *
 * Roles can be used to represent a set of permissions. To restrict access to a
 * function call, use {hasRole}:
 *
 * ```solidity
 * function foo() public {
 *     require(hasRole(MY_ROLE, msg.sender));
 *     ...
 * }
 * ```
 *
 * Roles can be granted and revoked dynamically via the {grantRole} and
 * {revokeRole} functions. Each role has an associated admin role, and only
 * accounts that have a role's admin role can call {grantRole} and {revokeRole}.
 *
 * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means
 * that only accounts with this role will be able to grant or revoke other
 * roles. More complex role relationships can be created by using
 * {_setRoleAdmin}.
 *
 * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to
 * grant and revoke this role. Extra precautions should be taken to secure
 * accounts that have been granted it. We recommend using {AccessControlDefaultAdminRules}
 * to enforce additional security measures for this role.
 */
abstract contract AccessControl is Context, IAccessControl, ERC165 {
    struct RoleData {
        mapping(address account => bool) hasRole;
        bytes32 adminRole;
    }

    mapping(bytes32 role => RoleData) private _roles;

    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;

    /**
     * @dev Modifier that checks that an account has a specific role. Reverts
     * with an {AccessControlUnauthorizedAccount} error including the required role.
     */
    modifier onlyRole(bytes32 role) {
        _checkRole(role);
        _;
    }

    /**
     * @dev See {IERC165-supportsInterface}.
     */
    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {
        return interfaceId == type(IAccessControl).interfaceId || super.supportsInterface(interfaceId);
    }

    /**
     * @dev Returns `true` if `account` has been granted `role`.
     */
    function hasRole(bytes32 role, address account) public view virtual returns (bool) {
        return _roles[role].hasRole[account];
    }

    /**
     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `_msgSender()`
     * is missing `role`. Overriding this function changes the behavior of the {onlyRole} modifier.
     */
    function _checkRole(bytes32 role) internal view virtual {
        _checkRole(role, _msgSender());
    }

    /**
     * @dev Reverts with an {AccessControlUnauthorizedAccount} error if `account`
     * is missing `role`.
     */
    function _checkRole(bytes32 role, address account) internal view virtual {
        if (!hasRole(role, account)) {
            revert AccessControlUnauthorizedAccount(account, role);
        }
    }

    /**
     * @dev Returns the admin role that controls `role`. See {grantRole} and
     * {revokeRole}.
     *
     * To change a role's admin, use {_setRoleAdmin}.
     */
    function getRoleAdmin(bytes32 role) public view virtual returns (bytes32) {
        return _roles[role].adminRole;
    }

    /**
     * @dev Grants `role` to `account`.
     *
     * If `account` had not been already granted `role`, emits a {RoleGranted}
     * event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     *
     * May emit a {RoleGranted} event.
     */
    function grantRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
        _grantRole(role, account);
    }

    /**
     * @dev Revokes `role` from `account`.
     *
     * If `account` had been granted `role`, emits a {RoleRevoked} event.
     *
     * Requirements:
     *
     * - the caller must have ``role``'s admin role.
     *
     * May emit a {RoleRevoked} event.
     */
    function revokeRole(bytes32 role, address account) public virtual onlyRole(getRoleAdmin(role)) {
        _revokeRole(role, account);
    }

    /**
     * @dev Revokes `role` from the calling account.
     *
     * Roles are often managed via {grantRole} and {revokeRole}: this function's
     * purpose is to provide a mechanism for accounts to lose their privileges
     * if they are compromised (such as when a trusted device is misplaced).
     *
     * If the calling account had been revoked `role`, emits a {RoleRevoked}
     * event.
     *
     * Requirements:
     *
     * - the caller must be `callerConfirmation`.
     *
     * May emit a {RoleRevoked} event.
     */
    function renounceRole(bytes32 role, address callerConfirmation) public virtual {
        if (callerConfirmation != _msgSender()) {
            revert AccessControlBadConfirmation();
        }

        _revokeRole(role, callerConfirmation);
    }

    /**
     * @dev Sets `adminRole` as ``role``'s admin role.
     *
     * Emits a {RoleAdminChanged} event.
     */
    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {
        bytes32 previousAdminRole = getRoleAdmin(role);
        _roles[role].adminRole = adminRole;
        emit RoleAdminChanged(role, previousAdminRole, adminRole);
    }

    /**
     * @dev Attempts to grant `role` to `account` and returns a boolean indicating if `role` was granted.
     *
     * Internal function without access restriction.
     *
     * May emit a {RoleGranted} event.
     */
    function _grantRole(bytes32 role, address account) internal virtual returns (bool) {
        if (!hasRole(role, account)) {
            _roles[role].hasRole[account] = true;
            emit RoleGranted(role, account, _msgSender());
            return true;
        } else {
            return false;
        }
    }

    /**
     * @dev Attempts to revoke `role` to `account` and returns a boolean indicating if `role` was revoked.
     *
     * Internal function without access restriction.
     *
     * May emit a {RoleRevoked} event.
     */
    function _revokeRole(bytes32 role, address account) internal virtual returns (bool) {
        if (hasRole(role, account)) {
            _roles[role].hasRole[account] = false;
            emit RoleRevoked(role, account, _msgSender());
            return true;
        } else {
            return false;
        }
    }
}

// src/provider/NormalizedPriceProvider.sol

/**
 * @title NormalizedPriceProvider
 * @custom:version 1.0.0
 * @author Sean Matt English (@smatthewenglish) 
 * @custom:coauthor Lorran Sutter (@LorranSutter)
 * @custom:coauthor Dylan Moreland (@elffjs)
 * @custom:coauthor Yevgeny Khessin (@zer0stars)
 * @custom:coauthor Rob Solomon (@robmsolomon)
 * @custom:contributor Allyson English (@aesdfghjkl666)
 * 
 * @dev Normalize the format of different oracle sources into a common source.
 */
contract NormalizedPriceProvider is AccessControl {

    /*//////////////////////////////////////////////////////////////
                             Access Controls
    //////////////////////////////////////////////////////////////*/
    bytes32 public constant UPDATER_ROLE = keccak256("UPDATER_ROLE");
    bytes32 public constant PROVIDER_ADMIN_ROLE = keccak256("PROVIDER_ADMIN_ROLE");

    uint256 public _primaryIndex;
    IOracleSource[] public _oracleSources;

    event PrimaryOracleSourceSet(uint256 indexed index);
    event OracleSourceRemoved(address indexed source);
    event OracleSourceAdded(address indexed source);

    uint256 constant MAX_ORACLE_SOURCES = 12;
    string constant private ERROR_INVALID_INDEX = "NormalizedPriceProvider: invalid index";
    string constant private ERROR_MAX_ORACLES_REACHED = "NormalizedPriceProvider: max oracle sources reached";

    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
    }

    function addOracleSource(address source) external onlyRole(PROVIDER_ADMIN_ROLE) {
        require(source != address(0), "NormalizedPriceProvider: invalid source address");
        require(_oracleSources.length < MAX_ORACLE_SOURCES, ERROR_MAX_ORACLES_REACHED);
        _oracleSources.push(IOracleSource(source));
        emit OracleSourceAdded(source);
    }

    function setPrimaryOracleSource(uint256 index) external onlyRole(PROVIDER_ADMIN_ROLE) {
        require(index < _oracleSources.length, ERROR_INVALID_INDEX);
        _primaryIndex = index;
        emit PrimaryOracleSourceSet(_primaryIndex);
    }

    /**
     * Remove the oracle source from the array by swapping it with 
     * the last element and then popping from the array
     */
    function removeOracleSource(uint256 indexToRemove) external onlyRole(PROVIDER_ADMIN_ROLE) {
        require(indexToRemove < _oracleSources.length && 
                indexToRemove != _primaryIndex, ERROR_INVALID_INDEX);

        emit OracleSourceRemoved(address(_oracleSources[indexToRemove]));
        
        _oracleSources[indexToRemove] = _oracleSources[_oracleSources.length - 1];
        _oracleSources.pop();
    }

    /**
     * This function costs us $LINK and costs the caller gas.
     */
    function updatePrice() external onlyRole(UPDATER_ROLE) {
        _oracleSources[_primaryIndex].updatePrice();
    }

    function getPrimaryOracleSource() external view returns (address primaryOracleSource) {
        primaryOracleSource = address(_oracleSources[_primaryIndex]);
    }

    function getAllOracleSources() external view returns (address[] memory) {
        address[] memory oracleSources = new address[](_oracleSources.length);
        for(uint256 i = 0; i < _oracleSources.length; i++) {
            oracleSources[i] = address(_oracleSources[i]);
        }
        return oracleSources;
    }

    function getAmountUsdPerToken() public returns (uint256 amountUsdPerToken, uint256 updateTimestamp) {
        (amountUsdPerToken, updateTimestamp) = this.getAmountUsdPerToken("");
    }

    function getAmountUsdPerToken(bytes calldata data) public returns (uint256 amountUsdPerToken, uint256 updateTimestamp) {
        (amountUsdPerToken, updateTimestamp) = _oracleSources[_primaryIndex].getAmountUsdPerToken(data);
    }

    function isUpdatable() external view returns (bool updatable) {
        updatable = _oracleSources[_primaryIndex].isUpdatable();
    }

}

// src/DevLicenseCore.sol

contract DevLicenseCore is IDevLicenseDimo, AccessControl {

    /*//////////////////////////////////////////////////////////////
                             Access Controls
    //////////////////////////////////////////////////////////////*/
    
    bytes32 public constant LICENSE_ADMIN_ROLE = keccak256("LICENSE_ADMIN_ROLE");

    /*//////////////////////////////////////////////////////////////
                              Member Variables
    //////////////////////////////////////////////////////////////*/
    
    IDimoToken public _dimoToken; 
    IDimoCredit public _dimoCredit;
    NormalizedPriceProvider public _provider;
    ILicenseAccountFactory public _licenseAccountFactory;
    
    ///@dev signer validity expiration
    uint256 public _periodValidity; 
    uint256 public _licenseCostInUsd1e18;
    uint256 public _counter;
    ///@dev receives proceeds from sale of license
    address public _receiver;

    /*//////////////////////////////////////////////////////////////
                              Mappings
    //////////////////////////////////////////////////////////////*/
    
    mapping(uint256 => address) public _ownerOf;
    mapping(uint256 => address) public _tokenIdToClientId;
    mapping(address => uint256) public _clientIdToTokenId;
    
    ///@dev expiration determined by block.timestamp
    mapping(uint256 => mapping(address => uint256)) public _signers; 

    /*//////////////////////////////////////////////////////////////
                            Events
    //////////////////////////////////////////////////////////////*/
    
    ///@dev on mint & burn
    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId); 
    event SignerEnabled(uint256 indexed tokenId, address indexed signer);
    event Locked(uint256 indexed tokenId);

    event UpdateLicenseCost(uint256 licenseCost);
    event UpdateReceiverAddress(address receiver_);
    event UpdateDimoTokenAddress(address dimoToken_);
    event UpdatePeriodValidity(uint256 periodValidity);
    event UpdatePriceProviderAddress(address provider);
    event UpdateDimoCreditAddress(address dimoCredit_);
    event UpdateLicenseAccountFactoryAddress(address licenseAccountFactory_);

    /*//////////////////////////////////////////////////////////////
                            Error Messages
    //////////////////////////////////////////////////////////////*/
    
    string INVALID_TOKEN_ID = "DevLicenseDimo: invalid tokenId";
    string INVALID_OPERATION = "DevLicenseDimo: invalid operation";
    string INVALID_MSG_SENDER = "DevLicenseDimo: invalid msg.sender";

    /*//////////////////////////////////////////////////////////////
                            Modifiers
    //////////////////////////////////////////////////////////////*/

    modifier onlyTokenOwner(uint256 tokenId) { 
        require(msg.sender == ownerOf(tokenId), INVALID_MSG_SENDER);
        _;
    }

    constructor(
        address receiver_,
        address licenseAccountFactory_,
        address provider_,
        address dimoTokenAddress_, 
        address dimoCreditAddress_,
        uint256 licenseCostInUsd1e18_) {

        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        
        _periodValidity = 365 days;

        _receiver = receiver_;

        _dimoCredit = IDimoCredit(dimoCreditAddress_);
        _provider = NormalizedPriceProvider(provider_);
    
        _licenseAccountFactory = ILicenseAccountFactory(licenseAccountFactory_);
        _dimoToken = IDimoToken(dimoTokenAddress_);
        _licenseCostInUsd1e18 = licenseCostInUsd1e18_;

        emit UpdatePeriodValidity(_periodValidity);
        emit UpdateLicenseCost(_licenseCostInUsd1e18);
    }

    /*//////////////////////////////////////////////////////////////
                       Signer a.k.a. API Key
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice License can be minted by any EOA and assigned an owner, 
     * or by the owner directly. the owner then enables a key and/or set
     * of keys to act as a signer, to sign challenges from the backend 
     * to access API resources.
     */
    function enableSigner(uint256 tokenId, address signer) onlyTokenOwner(tokenId) external {
        _enableSigner(tokenId, signer);
    }

    function _enableSigner(uint256 tokenId, address signer) internal {
        _signers[tokenId][signer] = block.timestamp;
        emit SignerEnabled(tokenId, signer);
    }

    function isSigner(uint256 tokenId, address signer) public view returns (bool) {
        uint256 timestampInit = _signers[tokenId][signer];
        uint256 timestampCurrent = block.timestamp;
        if(timestampCurrent - timestampInit > _periodValidity) {
            return false;
        } else {
            return true;
        }
    }

    /*//////////////////////////////////////////////////////////////
                            Admin Functions
    //////////////////////////////////////////////////////////////*/

    function setReceiverAddress(address receiver_) external onlyRole(LICENSE_ADMIN_ROLE) {
        _receiver = receiver_;
        emit UpdateReceiverAddress(_receiver);
    }

    function setLicenseCost(uint256 licenseCostInUsd1e18_) external onlyRole(LICENSE_ADMIN_ROLE) {
        _licenseCostInUsd1e18 = licenseCostInUsd1e18_;
        emit UpdateLicenseCost(_licenseCostInUsd1e18);
    }

    function setPeriodValidity(uint256 periodValidity_) external onlyRole(LICENSE_ADMIN_ROLE) {
        _periodValidity = periodValidity_;
        emit UpdatePeriodValidity(_periodValidity);
    }

    function setPriceProviderAddress(address providerAddress_) external onlyRole(LICENSE_ADMIN_ROLE) {
        _provider = NormalizedPriceProvider(providerAddress_);
        emit UpdatePriceProviderAddress(providerAddress_);
    }

    function setDimoCreditAddress(address dimoCreditAddress_) external onlyRole(LICENSE_ADMIN_ROLE) {
        _dimoCredit = IDimoCredit(dimoCreditAddress_);
        emit UpdateDimoCreditAddress(dimoCreditAddress_);
    }

    function setDimoTokenAddress(address dimoTokenAddress_) external onlyRole(LICENSE_ADMIN_ROLE) {
        _dimoToken = IDimoToken(dimoTokenAddress_);
        emit UpdateDimoTokenAddress(dimoTokenAddress_);
    }
    
    function setLicenseFactoryAddress(address licenseAccountFactory_) external onlyRole(LICENSE_ADMIN_ROLE) {
        _licenseAccountFactory = ILicenseAccountFactory(licenseAccountFactory_);
        emit UpdateLicenseAccountFactoryAddress(licenseAccountFactory_);
    }

    /*//////////////////////////////////////////////////////////////
                             NO-OP NFT Logic
    //////////////////////////////////////////////////////////////*/

    function approve(address /*spender*/, uint256 /*id*/) public virtual {
        revert(INVALID_OPERATION);
    }

    function setApprovalForAll(address /*operator*/, bool /*approved*/) public virtual {
        revert(INVALID_OPERATION);
    }

    function transferFrom(address /*from*/, address /*to*/, uint256 /*id*/) public virtual {
        revert(INVALID_OPERATION);
    }

    function safeTransferFrom(
        address /*from*/,
        address /*to*/,
        uint256 /*id*/
    ) public virtual {
        revert(INVALID_OPERATION);
    }

    function safeTransferFrom(
        address /*from*/,
        address /*to*/,
        uint256 /*id*/,
        bytes memory /*data*/
    ) public virtual {
        revert(INVALID_OPERATION);
    }

    /*//////////////////////////////////////////////////////////////
                              NFT Logic
    //////////////////////////////////////////////////////////////*/

    function totalSupply() external view returns (uint256 totalSupply_) {
        totalSupply_ = _counter;
    } 

    function ownerOf(uint256 tokenId) public view virtual returns (address owner) {
        require((owner = _ownerOf[tokenId]) != address(0), INVALID_TOKEN_ID);
    }

    /*//////////////////////////////////////////////////////////////
                            SBT Logic
    //////////////////////////////////////////////////////////////*/

    /**
     * @dev ERC5192: Minimal Soulbound NFTs Minimal interface for 
     * soulbinding EIP-721 NFTs
     */
    function locked(uint256 tokenId) external view returns (bool locked_) {
        require(locked_ = _exists(tokenId), INVALID_TOKEN_ID);
    }

    /*//////////////////////////////////////////////////////////////
                         Private Helper Functions
    //////////////////////////////////////////////////////////////*/

    function _exists(uint256 tokenId) private view returns (bool) {
        return _ownerOf[tokenId] != address(0);
    }

    /*//////////////////////////////////////////////////////////////
                              ERC165 LOGIC
    //////////////////////////////////////////////////////////////*/
    
    function supportsInterface(bytes4 interfaceId) public override pure returns (bool) {
        return
            interfaceId == 0x80ac58cd || // ERC165 Interface ID for ERC721
            interfaceId == 0xb45a3c0e || // ERC165 Interface ID for ERC5192
            interfaceId == 0x5b5e139f;   // ERC165 Interface ID for ERC721Metadata
    }

}

// src/DevLicenseStake.sol

/** 
 * https://dimo.zone/news/on-dimo-tokenomics
 */
contract DevLicenseStake is DevLicenseCore, ReentrancyGuard {

    /*//////////////////////////////////////////////////////////////
                              Member Variable
    //////////////////////////////////////////////////////////////*/
    
    uint256 public _stakeTotal;

    /*//////////////////////////////////////////////////////////////
                              Mappings
    //////////////////////////////////////////////////////////////*/

    mapping(uint256 => bool) public _frozen;
    mapping(uint256 => uint256) public _stakeLicense;

    /*//////////////////////////////////////////////////////////////
                            Events
    //////////////////////////////////////////////////////////////*/

    event AssetFreezeUpdate(uint256 indexed tokenId, uint256 amount, bool frozen);
    event AssetForfeit(uint256 indexed tokenId, uint256 amount);
    event StakeDeposit(uint256 indexed tokenId, address indexed user, uint256 amount);
    event StakeWithdraw(uint256 indexed tokenId, address indexed user, uint256 amount);

    /*//////////////////////////////////////////////////////////////
                            Error Messages
    //////////////////////////////////////////////////////////////*/

    string INVALID_PARAM = "DevLicenseDimo: invalid param";

    constructor(
        address receiver_,
        address licenseAccountFactory_,
        address provider_,
        address dimoTokenAddress_, 
        address dimoCreditAddress_,
        uint256 licenseCostInUsd_
    ) DevLicenseCore(receiver_, licenseAccountFactory_, provider_, dimoTokenAddress_, dimoCreditAddress_, licenseCostInUsd_) ReentrancyGuard() {}

    /*//////////////////////////////////////////////////////////////
                         Operative Functions
    //////////////////////////////////////////////////////////////*/

    /**
     */
    function lock(uint256 tokenId, uint256 amount) external {
        require(msg.sender == ownerOf(tokenId), INVALID_PARAM);

        _dimoToken.transferFrom(msg.sender, address(this), amount);

        _stakeLicense[tokenId] += amount;
        _stakeTotal += amount;

        emit StakeDeposit(tokenId, msg.sender, amount);
    }

    /**
     */
    function withdraw(uint256 tokenId, uint256 amount) public nonReentrant {
        require(amount > 0, INVALID_PARAM);
        require(msg.sender == ownerOf(tokenId), INVALID_PARAM);
        require(!_frozen[tokenId], "DevLicenseDimo: funds inaccessible");
        require(_stakeLicense[tokenId] >= amount, INVALID_PARAM);

        _transferOut(tokenId, amount);
        _dimoToken.transferFrom(address(this), msg.sender, amount);

        emit StakeWithdraw(tokenId, msg.sender, amount);
    }

    /*//////////////////////////////////////////////////////////////
                            View Functions
    //////////////////////////////////////////////////////////////*/

    function totalStaked() public view returns (uint256 totalStaked_) {
        totalStaked_ = _stakeTotal;
    }

    function licenseStaked(uint256 tokenId) public view returns (uint256 licenseStaked_) {
        licenseStaked_ = _stakeLicense[tokenId];
    }

    /*//////////////////////////////////////////////////////////////
                     Private Helper Function
    //////////////////////////////////////////////////////////////*/

    /**
     */
    function _transferOut(uint256 tokenId, uint256 amount) private {
        _stakeLicense[tokenId] -= amount;
        _stakeTotal -= amount;
    }

    /*//////////////////////////////////////////////////////////////
                            Admin Functions
    //////////////////////////////////////////////////////////////*/

    /**
     * @notice freeze assets in case of violation
     */
    function adminFreeze(uint256 tokenId, bool frozen) external onlyRole(LICENSE_ADMIN_ROLE) {
        _frozen[tokenId] = frozen;
        emit AssetFreezeUpdate(tokenId, _stakeLicense[tokenId], frozen);
    }

    /**
     * @notice forefeit assets in case of violation 
     */
    function adminBurnLockedFunds(uint256 tokenId, uint256 amount) external onlyRole(LICENSE_ADMIN_ROLE) {
        require(_stakeLicense[tokenId] >= amount, INVALID_PARAM);

        _transferOut(tokenId, amount);

        _dimoToken.burn(address(this), amount);
        emit AssetForfeit(tokenId, amount);
    }

    /**
     * @dev generalized admin transfer function
     */
    function adminReallocate(uint256 tokenId, uint256 amount, address to) external onlyRole(LICENSE_ADMIN_ROLE) {
        require(_stakeLicense[tokenId] <= amount, INVALID_PARAM);

        _transferOut(tokenId, amount);

        _dimoToken.transfer(to, amount);
        emit AssetForfeit(tokenId, amount);
    }

    /**
     * @dev in case funds get send to this contract as part of a donation attack, etc
     * only able to withdraw the difference btwn total lock, and balance of this contract.
     */
    function adminWithdraw(address to) external onlyRole(LICENSE_ADMIN_ROLE) {
        uint256 balaceOf = _dimoToken.balanceOf(address(this));
        uint256 amount = balaceOf - _stakeTotal;
        _dimoToken.transfer(to, amount);
    }

}

// src/DevLicenseMeta.sol

contract DevLicenseMeta is DevLicenseStake {

    string public _imageToken;
    string public _imageContract;
    string public _descriptionToken;
    string public _descriptionContract;

    constructor(
        address receiver_,
        address licenseAccountFactory_,
        address provider_,
        address dimoTokenAddress_, 
        address dimoCreditAddress_,
        uint256 licenseCostInUsd_) 
    DevLicenseStake(
        receiver_,
        licenseAccountFactory_,
        provider_,
        dimoTokenAddress_, 
        dimoCreditAddress_,
        licenseCostInUsd_
    ) {
        string memory image = '<svg width="1872" height="1872" viewBox="0 0 1872 1872" fill="none" xmlns="http://www.w3.org/2000/svg"> <rect width="1872" height="1872" fill="#191919"/> <g clip-path="url(#clip0_736_195)"> <path fill-rule="evenodd" clip-rule="evenodd" d="M1344.86 1005.3C1365.39 1013.67 1387.4 1017.89 1409.59 1017.71C1431.78 1017.93 1453.8 1013.73 1474.35 1005.38C1494.9 997.017 1513.57 984.662 1529.26 969.034C1544.97 953.408 1557.37 934.818 1565.77 914.359C1574.17 893.898 1578.39 871.976 1578.17 849.874C1578.39 827.769 1574.17 805.844 1565.78 785.38C1557.38 764.916 1544.98 746.325 1529.28 730.694C1513.58 715.063 1494.91 702.706 1474.36 694.347C1453.8 685.987 1431.79 681.792 1409.59 682.008C1387.4 681.829 1365.4 686.048 1344.86 694.418C1324.33 702.789 1305.68 715.145 1289.99 730.765C1274.3 746.386 1261.89 764.959 1253.48 785.403C1245.07 805.846 1240.82 827.753 1241 849.845C1240.82 871.939 1245.06 893.848 1253.46 914.296C1261.87 934.743 1274.29 953.319 1289.98 968.943C1305.67 984.566 1324.32 996.926 1344.86 1005.3ZM1535.43 849.845C1535.43 921.18 1481.23 977.456 1409.59 977.456C1338.39 977.456 1284.19 921.211 1284.19 849.845C1284.19 778.478 1338.39 722.234 1409.59 722.234C1481.23 722.234 1535.43 778.508 1535.43 849.845Z" fill="white"/> <path d="M1155.64 1010.52H1199.46V753.502C1199.44 735.747 1192.34 718.726 1179.73 706.171C1167.13 693.616 1150.03 686.552 1132.2 686.529C1119.44 686.562 1106.95 690.196 1096.18 697.009C1085.4 703.821 1076.79 713.534 1071.33 725.021L967.306 945.486C965.402 949.488 962.401 952.873 958.645 955.249C954.889 957.623 950.536 958.889 946.089 958.904C943.009 958.904 939.962 958.302 937.117 957.128C934.274 955.956 931.689 954.235 929.512 952.069C927.338 949.899 925.61 947.327 924.432 944.497C923.254 941.664 922.649 938.63 922.649 935.563V775.229C922.624 751.711 913.231 729.164 896.53 712.534C879.83 695.905 857.187 686.552 833.568 686.529C809.956 686.56 787.322 695.916 770.626 712.545C753.934 729.173 744.543 751.716 744.52 775.229V1010.49H788.34V775.229C788.356 763.286 793.125 751.837 801.603 743.389C810.08 734.942 821.575 730.185 833.568 730.161C845.567 730.177 857.071 734.93 865.554 743.379C874.039 751.827 878.814 763.281 878.829 775.229V935.563C878.844 953.322 885.937 970.348 898.546 982.905C911.158 995.46 928.253 1002.52 946.089 1002.54C958.85 1002.51 971.343 998.876 982.115 992.063C992.888 985.247 1001.5 975.534 1006.96 964.045L1110.98 743.58C1112.89 739.579 1115.89 736.196 1119.65 733.822C1123.4 731.448 1127.75 730.179 1132.2 730.161C1138.41 730.169 1144.37 732.631 1148.77 737.006C1153.16 741.382 1155.63 747.314 1155.64 753.502V1010.52Z" fill="white"/> <path d="M643.066 686.676H685.535V1010.54H643.066V686.676Z" fill="white"/> <path fill-rule="evenodd" clip-rule="evenodd" d="M597.577 848.596C597.577 755.981 524.284 686.676 424.43 686.676H329.291L329.291 1010.26H373.588L424.43 1010.54C524.284 1010.54 597.577 941.21 597.577 848.596ZM373.588 726.364L424.43 726.364C502.765 726.364 554.508 778.365 554.508 848.596C554.508 918.826 502.765 970.857 424.43 970.857H373.588V726.364Z" fill="white"/> </g> <path d="M341.862 1217.87H322.699V1163.81H342.021C347.458 1163.81 352.139 1164.89 356.063 1167.06C359.988 1169.2 363.006 1172.29 365.117 1176.32C367.247 1180.35 368.311 1185.17 368.311 1190.79C368.311 1196.42 367.247 1201.26 365.117 1205.3C363.006 1209.35 359.97 1212.46 356.011 1214.62C352.069 1216.79 347.353 1217.87 341.862 1217.87ZM334.128 1208.08H341.387C344.766 1208.08 347.608 1207.48 349.913 1206.28C352.236 1205.07 353.978 1203.19 355.14 1200.66C356.319 1198.11 356.908 1194.82 356.908 1190.79C356.908 1186.79 356.319 1183.53 355.14 1180.99C353.978 1178.46 352.245 1176.59 349.939 1175.4C347.634 1174.2 344.792 1173.6 341.413 1173.6H334.128V1208.08ZM407.254 1217.87V1163.81H443.681V1173.23H418.684V1186.11H441.807V1195.54H418.684V1208.44H443.786V1217.87H407.254ZM493.01 1163.81L506.077 1204.88H506.578L519.671 1163.81H532.341L513.705 1217.87H498.976L480.314 1163.81H493.01ZM569.324 1217.87V1163.81H605.751V1173.23H580.753V1186.11H603.876V1195.54H580.753V1208.44H605.856V1217.87H569.324ZM645.313 1217.87V1163.81H656.743V1208.44H679.919V1217.87H645.313ZM765.537 1190.84C765.537 1196.73 764.419 1201.75 762.185 1205.88C759.967 1210.02 756.941 1213.18 753.104 1215.36C749.286 1217.53 744.992 1218.61 740.223 1218.61C735.419 1218.61 731.107 1217.52 727.289 1215.33C723.47 1213.15 720.452 1209.99 718.235 1205.86C716.017 1201.72 714.909 1196.72 714.909 1190.84C714.909 1184.94 716.017 1179.93 718.235 1175.79C720.452 1171.66 723.47 1168.51 727.289 1166.34C731.107 1164.16 735.419 1163.07 740.223 1163.07C744.992 1163.07 749.286 1164.16 753.104 1166.34C756.941 1168.51 759.967 1171.66 762.185 1175.79C764.419 1179.93 765.537 1184.94 765.537 1190.84ZM753.949 1190.84C753.949 1187.02 753.377 1183.8 752.233 1181.18C751.107 1178.56 749.514 1176.57 747.455 1175.21C745.397 1173.86 742.986 1173.18 740.223 1173.18C737.46 1173.18 735.049 1173.86 732.99 1175.21C730.931 1176.57 729.33 1178.56 728.186 1181.18C727.06 1183.8 726.497 1187.02 726.497 1190.84C726.497 1194.66 727.06 1197.88 728.186 1200.5C729.33 1203.12 730.931 1205.11 732.99 1206.46C735.049 1207.82 737.46 1208.5 740.223 1208.5C742.986 1208.5 745.397 1207.82 747.455 1206.46C749.514 1205.11 751.107 1203.12 752.233 1200.5C753.377 1197.88 753.949 1194.66 753.949 1190.84ZM804.48 1217.87V1163.81H825.808C829.908 1163.81 833.401 1164.59 836.287 1166.16C839.173 1167.71 841.373 1169.86 842.886 1172.62C844.417 1175.37 845.183 1178.54 845.183 1182.13C845.183 1185.72 844.408 1188.89 842.86 1191.63C841.311 1194.38 839.068 1196.51 836.129 1198.04C833.208 1199.58 829.67 1200.34 825.517 1200.34H811.923V1191.18H823.67C825.869 1191.18 827.682 1190.8 829.107 1190.05C830.55 1189.27 831.624 1188.21 832.328 1186.85C833.049 1185.48 833.41 1183.9 833.41 1182.13C833.41 1180.33 833.049 1178.77 832.328 1177.43C831.624 1176.07 830.55 1175.03 829.107 1174.29C827.664 1173.53 825.834 1173.15 823.617 1173.15H815.909V1217.87H804.48ZM883.083 1217.87V1163.81H919.51V1173.23H894.512V1186.11H917.635V1195.54H894.512V1208.44H919.615V1217.87H883.083ZM959.073 1217.87V1163.81H980.401C984.483 1163.81 987.968 1164.54 990.854 1166C993.757 1167.44 995.966 1169.49 997.479 1172.15C999.01 1174.79 999.776 1177.9 999.776 1181.47C999.776 1185.06 999.001 1188.15 997.453 1190.73C995.904 1193.3 993.66 1195.27 990.722 1196.65C987.801 1198.02 984.263 1198.7 980.11 1198.7H965.83V1189.52H978.263C980.445 1189.52 982.257 1189.22 983.7 1188.62C985.143 1188.02 986.217 1187.13 986.921 1185.93C987.642 1184.73 988.003 1183.25 988.003 1181.47C988.003 1179.67 987.642 1178.16 986.921 1176.93C986.217 1175.7 985.134 1174.76 983.674 1174.13C982.231 1173.48 980.41 1173.15 978.21 1173.15H970.502V1217.87H959.073ZM988.267 1193.27L1001.7 1217.87H989.085L975.94 1193.27H988.267ZM1086.01 1217.87V1163.81H1097.44V1208.44H1120.61V1217.87H1086.01ZM1170.09 1163.81V1217.87H1158.66V1163.81H1170.09ZM1257.67 1182.73H1246.11C1245.89 1181.24 1245.46 1179.91 1244.81 1178.75C1244.16 1177.57 1243.32 1176.57 1242.3 1175.74C1241.28 1174.91 1240.1 1174.28 1238.77 1173.84C1237.45 1173.4 1236.01 1173.18 1234.46 1173.18C1231.67 1173.18 1229.23 1173.87 1227.15 1175.26C1225.08 1176.64 1223.47 1178.64 1222.32 1181.28C1221.18 1183.9 1220.61 1187.09 1220.61 1190.84C1220.61 1194.69 1221.18 1197.93 1222.32 1200.55C1223.48 1203.17 1225.1 1205.15 1227.18 1206.49C1229.26 1207.83 1231.66 1208.5 1234.39 1208.5C1235.92 1208.5 1237.33 1208.3 1238.64 1207.89C1239.96 1207.49 1241.13 1206.9 1242.15 1206.12C1243.17 1205.33 1244.01 1204.37 1244.68 1203.24C1245.37 1202.12 1245.84 1200.83 1246.11 1199.39L1257.67 1199.44C1257.37 1201.92 1256.62 1204.32 1255.42 1206.62C1254.24 1208.91 1252.65 1210.96 1250.65 1212.77C1248.66 1214.57 1246.28 1215.99 1243.52 1217.05C1240.77 1218.09 1237.67 1218.61 1234.2 1218.61C1229.38 1218.61 1225.07 1217.52 1221.27 1215.33C1217.48 1213.15 1214.49 1209.99 1212.29 1205.86C1210.11 1201.72 1209.02 1196.72 1209.02 1190.84C1209.02 1184.94 1210.13 1179.93 1212.34 1175.79C1214.56 1171.66 1217.57 1168.51 1221.37 1166.34C1225.17 1164.16 1229.45 1163.07 1234.2 1163.07C1237.33 1163.07 1240.24 1163.51 1242.91 1164.39C1245.6 1165.27 1247.99 1166.55 1250.06 1168.24C1252.14 1169.91 1253.83 1171.97 1255.13 1174.39C1256.45 1176.82 1257.3 1179.6 1257.67 1182.73ZM1296.34 1217.87V1163.81H1332.77V1173.23H1307.77V1186.11H1330.89V1195.54H1307.77V1208.44H1332.87V1217.87H1296.34ZM1417.55 1163.81V1217.87H1407.67L1384.15 1183.84H1383.76V1217.87H1372.33V1163.81H1382.36L1405.69 1197.81H1406.17V1163.81H1417.55ZM1486.79 1179.36C1486.58 1177.23 1485.67 1175.57 1484.07 1174.39C1482.47 1173.21 1480.3 1172.62 1477.55 1172.62C1475.69 1172.62 1474.11 1172.89 1472.83 1173.42C1471.54 1173.93 1470.56 1174.64 1469.87 1175.55C1469.2 1176.47 1468.87 1177.51 1468.87 1178.67C1468.83 1179.64 1469.04 1180.48 1469.48 1181.2C1469.93 1181.93 1470.56 1182.55 1471.35 1183.08C1472.14 1183.59 1473.06 1184.04 1474.09 1184.42C1475.13 1184.79 1476.24 1185.11 1477.42 1185.37L1482.28 1186.54C1484.64 1187.06 1486.8 1187.77 1488.77 1188.65C1490.74 1189.53 1492.45 1190.61 1493.89 1191.89C1495.33 1193.18 1496.45 1194.69 1497.24 1196.43C1498.05 1198.18 1498.47 1200.17 1498.48 1202.43C1498.47 1205.73 1497.62 1208.6 1495.95 1211.03C1494.3 1213.44 1491.9 1215.32 1488.77 1216.65C1485.66 1217.97 1481.9 1218.63 1477.5 1218.63C1473.14 1218.63 1469.33 1217.96 1466.1 1216.63C1462.88 1215.29 1460.36 1213.31 1458.55 1210.69C1456.75 1208.05 1455.81 1204.78 1455.72 1200.9H1466.78C1466.91 1202.71 1467.43 1204.22 1468.34 1205.44C1469.27 1206.63 1470.51 1207.54 1472.06 1208.15C1473.63 1208.75 1475.4 1209.05 1477.37 1209.05C1479.3 1209.05 1480.98 1208.77 1482.41 1208.21C1483.85 1207.64 1484.97 1206.86 1485.76 1205.86C1486.55 1204.85 1486.95 1203.7 1486.95 1202.4C1486.95 1201.19 1486.59 1200.17 1485.87 1199.34C1485.16 1198.51 1484.13 1197.81 1482.75 1197.23C1481.4 1196.65 1479.73 1196.12 1477.76 1195.64L1471.88 1194.16C1467.32 1193.06 1463.72 1191.32 1461.08 1188.96C1458.44 1186.61 1457.13 1183.43 1457.15 1179.44C1457.13 1176.16 1458 1173.3 1459.76 1170.86C1461.54 1168.41 1463.98 1166.5 1467.07 1165.13C1470.17 1163.76 1473.69 1163.07 1477.63 1163.07C1481.64 1163.07 1485.15 1163.76 1488.14 1165.13C1491.15 1166.5 1493.49 1168.41 1495.16 1170.86C1496.83 1173.3 1497.69 1176.14 1497.75 1179.36H1486.79ZM1536.65 1217.87V1163.81H1573.08V1173.23H1548.08V1186.11H1571.2V1195.54H1548.08V1208.44H1573.18V1217.87H1536.65Z" fill="white"/> <defs> <clipPath id="clip0_736_195"> <rect width="1249.71" height="335.718" fill="white" transform="translate(329.291 682)"/> </clipPath> </defs> </svg>';
        _imageToken = Base64.encode(bytes(image));
        _imageContract = Base64.encode(bytes(image));

        string memory description = "This is an NFT collection minted for developers building on the DIMO Network.";
        _descriptionToken = description;
        _descriptionContract = description;
    }

    /*//////////////////////////////////////////////////////////////
                          Admin Functions
    //////////////////////////////////////////////////////////////*/

    function setImageToken(string calldata image_) external onlyRole(LICENSE_ADMIN_ROLE) {
        _imageToken = Base64.encode(bytes(image_));
    }

    function setImageContract(string calldata image_) external onlyRole(LICENSE_ADMIN_ROLE) {
        _imageContract = Base64.encode(bytes(image_));
    }

    function setDescriptionToken(string calldata description_) external onlyRole(LICENSE_ADMIN_ROLE) {
        _descriptionToken = description_;
    }

    function setDescriptionContract(string calldata description_) external onlyRole(LICENSE_ADMIN_ROLE) {
        _descriptionContract = description_;
    }

    /*//////////////////////////////////////////////////////////////
                            NFT Metadata
    //////////////////////////////////////////////////////////////*/

    function contractURI() external view returns (string memory) {
        return string(
            abi.encodePacked(
                "data:application/json;base64,",
                Base64.encode(
                    bytes(
                        abi.encodePacked(
                            '{"name":"DIMO Developer License",'
                            '"description":', _descriptionContract, ','
                            '"image": "',
                            "data:image/svg+xml;base64,",
                            _imageContract,
                            '",' '"external_link": "https://dimo.zone/",'
                            '"collaborators": ["0x0000000000000000000000000000000000000000"]}'
                        )
                    )
                )
            )
        );
    }

    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {
        return string(
            abi.encodePacked(
                "data:application/json;base64,",
                Base64.encode(
                    bytes(
                        abi.encodePacked(
                            '{"name":"',
                            string(abi.encodePacked("DIMO Developer License #", Strings.toString(tokenId))),
                            '", "description":"',
                            _descriptionToken,
                            '", "image": "',
                            "data:image/svg+xml;base64,",
                            _imageToken,
                            '"}'
                        )
                    )
                )
            )
        );
    }

}

// src/DevLicenseDimo.sol

/**
 *                    _..-------++._
 *                _.-'/ |      _||  \"--._
 *          __.--'`._/_\j_____/_||___\    `----.
 *     _.--'_____    |          \     _____    /
 *  _j    /,---.\   |        =o |   /,---.\   |_
 * [__]==// .-. \\==`===========/==// .-. \\=[__]
 *   `-._|\ `-' /|___\_________/___|\ `-' /|_.'
 *         `---'                     `---'
 * @title DIMO Developer License
 * @custom:version 1.0.0
 * @author Sean Matt English (@smatthewenglish)
 * @custom:coauthor Lorran Sutter (@LorranSutter)
 * @custom:coauthor Dylan Moreland (@elffjs)
 * @custom:coauthor Yevgeny Khessin (@zer0stars)
 * @custom:coauthor Rob Solomon (@robmsolomon)
 * @custom:contributor Allyson English (@aesdfghjkl666)
 * @custom:contributor James Li (@ilsemaj)
 */
contract DevLicenseDimo is DevLicenseMeta {

    /*//////////////////////////////////////////////////////////////
                             Access Controls
    //////////////////////////////////////////////////////////////*/

    bytes32 public constant REVOKER_ROLE = keccak256("REVOKER_ROLE");

    /*//////////////////////////////////////////////////////////////
                            Member Variables
    //////////////////////////////////////////////////////////////*/

    string public name;
    string public symbol;

    /*//////////////////////////////////////////////////////////////
                                Events
    //////////////////////////////////////////////////////////////*/

    event RedirectUriEnabled(uint256 indexed tokenId, string uri);
    event RedirectUriDisabled(uint256 indexed tokenId, string uri); 
    event Issued(uint256 indexed tokenId, address indexed owner, address indexed clientId);

    /*//////////////////////////////////////////////////////////////
                               Mappings
    //////////////////////////////////////////////////////////////*/
    
    mapping(uint256 => mapping(string => bool)) private _redirectUris;

    /* * */

    constructor(
        address receiver_,
        address licenseAccountFactory_,
        address provider_,
        address dimoTokenAddress_, 
        address dimoCreditAddress_,
        uint256 licenseCostInUsd_) 
    DevLicenseMeta(
        receiver_,
        licenseAccountFactory_,
        provider_,
        dimoTokenAddress_, 
        dimoCreditAddress_,
        licenseCostInUsd_
    ) {
        symbol = "DLX";
        name = "DIMO Developer License";
    }

    /*//////////////////////////////////////////////////////////////
                            Redirect URI
    //////////////////////////////////////////////////////////////*/

    function redirectUriStatus(uint256 tokenId, string calldata uri) external view returns (bool enabled) {
        enabled = _redirectUris[tokenId][uri];
    }

    /**
     */
    function setRedirectUri(
            uint256 tokenId, 
            bool enabled, 
            string calldata uri
        ) onlyTokenOwner(tokenId) external {
            if(enabled) {
                emit RedirectUriEnabled(tokenId, uri);
            } else {
                emit RedirectUriDisabled(tokenId, uri);
            }
        _redirectUris[tokenId][uri] = enabled;
    }

    function removeRedirectUri(uint256 tokenId, string calldata uri) onlyTokenOwner(tokenId) external {
        delete _redirectUris[tokenId][uri];
        emit RedirectUriDisabled(tokenId, uri);
    }

    /*//////////////////////////////////////////////////////////////
                            License Logic
    //////////////////////////////////////////////////////////////*/

    function issueInDimo() external returns (uint256 tokenId, address clientId) {
        return issueInDimo(msg.sender);
    }

    /**
     * @dev transfer spent $DIMO to the DimoCredit receiver
     */
    function issueInDimo(address to) public returns (uint256 tokenId, address clientId) {
        
        (uint256 amountUsdPerToken,) = _provider.getAmountUsdPerToken();
        
        uint256 tokenTransferAmount = (_licenseCostInUsd1e18 / amountUsdPerToken) * 1 ether;
        
        _dimoToken.transferFrom(to, _receiver, tokenTransferAmount);

        return _issue(to);
    }

    function issueInDc() external returns (uint256 tokenId, address clientId) {
        return issueInDc(msg.sender);
    }

    /**
     */
    function issueInDc(address to) public returns (uint256 tokenId, address clientId) {
        uint256 dcTransferAmount = (_licenseCostInUsd1e18 / _dimoCredit.dimoCreditRate()) * 1 ether;
        _dimoCredit.burn(to, dcTransferAmount);

        return _issue(to);
    }

    /**
     * @notice clientId is the DimoDeveloperLicenseAccount that holds the token
     */
    function _issue(address to) private returns (uint256 tokenId, address clientId) {
        tokenId = ++_counter;
        clientId = _licenseAccountFactory.create(tokenId);

        _tokenIdToClientId[tokenId] = clientId;
        _clientIdToTokenId[clientId] = tokenId;
        _ownerOf[tokenId] = to;

        emit Issued(tokenId, to, clientId);
        emit Locked(tokenId); ///@dev ERC5192
        emit Transfer(address(0), to, tokenId); ///@dev ERC721
    }

    /**
     * @notice only admin enabled addresses are allowed to revoke/burn licenses
     */
    function revoke(uint256 tokenId) external onlyRole(REVOKER_ROLE) {
        require(_stakeLicense[tokenId] == 0, "DevLicenseDimo: resolve staked funds prior to revocation");

        address tokenOwner = _ownerOf[tokenId];
        delete _ownerOf[tokenId];
        
        address clientId = _tokenIdToClientId[tokenId];
        delete _tokenIdToClientId[tokenId];
        delete _clientIdToTokenId[clientId];

        emit Transfer(tokenOwner, address(0), tokenId); ///@dev ERC721
    }

}

